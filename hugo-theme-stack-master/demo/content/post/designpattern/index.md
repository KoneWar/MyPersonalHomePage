---
title: 设计模式
date: 2026-02-06
description: 我的设计模式笔记
tags:
    - 设计模式
    - 工厂
    - 软件设计
categories:
    - 笔记
image: pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg
toc: false
---



## 设计模式

GOF设计模式

作用：在变化和稳定中间，寻找隔离点，从而管理变化

底层思维

- 语言构造
- 编译转换
- 内存模型
- 运行时机制

抽象思维

- 面向对象（封装，继承，多态）
- 组件封装
- 设计模式
- 架构模式



###### 如何解决复杂性	“变化”

分解（分而治之）	**抽象**（重用性）



#### 软件设计的目标：**复用**

​	管理变化，提高复用



高内聚松耦合

对象：有责任的抽象



##### 面向对象设计原则

1. **DIP：依赖倒置原则**(变化依赖于稳定，提出抽象类)
   - 高层模块(稳定)和低层模块(变化)依赖于抽象(稳定)
   - 实现细节(变化)依赖于抽象
2. OCP：开放封闭原则(增加优于改变)
   - 对扩展开放，对更改封闭
   - 类模块是可扩展的，不可修改
3. SRP：单一职责原则
   - 一个类仅有一个引起它变化的原因
   - 变化的方向隐含着类的责任
4. LSP：Liskov替换原则
   - 子类必须能够替换它们的基类(IS-A)
   - 进程表达类型抽象
5. ISP：接口隔离原则
   - 接口小而完备
6. 对象组合优于类继承
   - 类继承：白箱复用；对象组合：黑箱复用
7. 封装变化点
   - 使用封装来创建对象之间的分界层
8. 针对接口编程优于针对实现编程
   - 接口标准化



###### Refactoring to Patterns

##### 重构关键技法

*差*			*优*

静态	    	动态

早绑定		晚绑定

继承		    组合

编译时依赖	运行时依赖

紧耦合		松耦合

稳定：非虚函数

变化：(纯)虚函数

扩展：继承+虚函数(多态)



设计经验

1. 设计习语：Design Idioms
2. 设计模式：Design Patterns
3. 架构模式：Architectural Patterns





分类

- 目的
  1. 创建型(Creational)
  2. 结构型(Structural)
  3. 行为型(Behavioral)	

- 范围
  - 类模式处理类与子类的静态关系
  - 对象模式处理对象间的动态关系



封装变化角度分类



##### “组件协作”模式：

典型模式

1. Template Method
2. Strategy
3. Observer/Event

 

##### “单一职责”模式：

继承—>组合

典型模式

1. Decorator
2. Bridge



##### “对象创建”模式：

隔离类对象的使用者和具体类型(易变)之间的耦合关系	紧耦合，绕开new

典型模式

1. Factory Method
2. Abstract Factory
3. Prototype
4. ###### Builder



##### “对象性能”模式：

性能

典型模式

1. Singleton
2. Flyweight



##### “接口隔离”模式：

添加一层间接(稳定)接口

典型模式

1. Facade
2. Proxy
3. Adapter
4. ###### Mediator



##### “状态变化”模式：

典型模式

1. State

2. ###### Memento



##### “数据结构”模式：

用接口代替封装的数据结构

典型模式

1. Composite

2. ###### Iterator

3. ###### Chain of Responsibility



##### “行为变化”模式：

解耦组件的行为和组件本身

典型模式

1. ###### Command

2. ###### Visitor



##### “领域规则”模式：

典型模式

1. ###### Interpreter



###### Template Method

动机：稳定的整体结构，各子步骤有很多改变的需求

定义：定义一个算法的骨架(稳定)，将变化到子类

早绑定		晚绑定



###### Strategy

动机：对象使用多种的算法，经常改变

定义：定义一系列的算法，并进行各个封装

扩展

动态的思考	时间轴

结构化：if-else	switch-case

​	

###### Observer

动机：通知依赖关系

定义：定义对象间的一种一对多的依赖关系

松耦合

基于事件的UI框架，MVC模式





###### Decorator

动机：过度地使用继承来扩展对象的功能

定义：运行时动态(组合)给一个对象增加一些额外的职责

消除重复代码，减少子类个数

同时继承和组合

解决主体类在多个方向上的扩展功能



###### Bridge

动机：多个维度的变化

定义：将抽象部分与实现部分分离，使得它们可以独立的变化

多个非常强的变化维度





###### Factory Method

动机：创建的对象的具体类型随需求变化而经常变化

定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类

目的：解耦

手段：虚函数



###### Abstract Factory

动机：一系列相互依赖的对象

定义：提供一个接口



###### Prototype

动机：结构复制的对象

定义：使用原型实例指定创建对象的种类，通过clone这些原型来创建新的对象



###### Builder

动机：一个复杂对象

定义：将一个复杂对象的构建与其表示相分离



###### Singleton

动机：只存在一个实例

定义：

并发



###### Flyweight

动机：存储

定义：运用共享技术有效地支持大量细粒度的对象

评估内存开销





###### Facade

动机：组件的客户和组件中各种子系统有过多的耦合

定义：为子系统中的一组接口提供一个一致的界面

系统间



###### Proxy

动机：分布式，性能，安全

定义：

软件系统



###### Adapter

动机：旧对象到新环境

定义：将一个类的接口转换成另一个接口

对象适配器

接口兼容，类库迁移



###### Mediator

动机：多个对象互相关联交互，维持复杂的运用关系

定义：用一个中介对象封装一系列的对象交互

编译时依赖	运行时依赖

系统内





###### State

动机：对象行为随着状态改变

定义：

类似Strategy



###### Memento

动机：程序回溯到对象之前的状态

定义：不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。

信息隐藏	序列化





###### Composite

动机：过于依赖对象内部实现结构

定义：将对象组合成树形结构，以表示“结构-整体”的层次结构

一致性

将”客户代码与复杂的对象容器结构“解耦



###### Iterator

动机：集合对象内部结构

定义：提供一种方法顺序访问一个聚合对象中的各个元素，不暴露对象的内部表示

泛型编程



###### Chain of Responsibility

动机：让请求的接收者自己在运行时决定处理请求

定义：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将对象连成一条链，沿着链传递请求





###### Command

动机：行为请求者与行为实现者的“紧耦合”

定义：将请求封装为对象



###### Visitor

动机：类层次结构需要增加新的行为

定义：表示一个作业于对象结构中的各元素的操作

double dispatch

适用于类层次结构稳定，其中的操作改动频繁





###### Interpreter

动机：类似的结构不断重复出现

定义：给定一个语言，抽象为语法结构



#### 经验之谈

- 不要为模式而模式
- 关注抽象类和接口
- 理清变化点和稳定点
- 审视依赖关系
- 要有Framework和Application的区隔思维
- 良好的设计是演化的结果
